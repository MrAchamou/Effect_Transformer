
export interface PreprocessingResult {
  isValid: boolean;
  cleanCode: string;
  changes: string[];
  metadata?: {
    effectName: string;
    effectId: string;
    category: string;
    version: string;
  };
  autoGeneratedReadme?: string;
  warnings: string[];
}

export class UniversalPreprocessor {
  private standardStructure = {
    requiredProperties: ['id', 'name', 'category', 'version', 'parameters'],
    requiredMethods: ['constructor', 'init', 'update', 'render'],
    performanceLevel: 'optimized',
    securityLevel: 'enhanced'
  };

  async preprocessEffect(rawCode: string, filename: string): Promise<PreprocessingResult> {
    const result: PreprocessingResult = {
      isValid: false,
      cleanCode: '',
      changes: [],
      warnings: []
    };

    try {
      // 1. Nettoyer le code initial
      let cleanCode = this.extractPureJavaScript(rawCode);
      result.changes.push('Code JavaScript pur extrait');

      // 2. Analyser la structure existante
      const analysis = this.analyzeCodeStructure(cleanCode);
      
      // 3. Standardiser selon notre structure
      cleanCode = this.standardizeStructure(cleanCode, analysis);
      result.changes.push('Structure standardisée selon notre format');

      // 4. Améliorer les performances
      cleanCode = this.optimizePerformance(cleanCode);
      result.changes.push('Optimisations de performance appliquées');

      // 5. Ajouter la sécurité
      cleanCode = this.enhanceSecurity(cleanCode);
      result.changes.push('Protections de sécurité ajoutées');

      // 6. Formater selon nos standards
      cleanCode = this.formatToStandard(cleanCode);
      result.changes.push('Formatage selon standards appliqué');

      // 7. Extraire les métadonnées
      result.metadata = this.extractMetadata(cleanCode, filename);

      // 8. Générer README automatique
      result.autoGeneratedReadme = this.generateAutoReadme(result.metadata, cleanCode);

      result.cleanCode = cleanCode;
      result.isValid = true;

      console.log(`✅ Reconditionnement réussi: ${result.changes.length} transformations`);

    } catch (error) {
      result.warnings.push(`Erreur de reconditionnement: ${error.message}`);
      console.error('❌ Erreur preprocessing:', error);
    }

    return result;
  }

  private extractPureJavaScript(rawCode: string): string {
    // Supprimer les commentaires multilignes
    let clean = rawCode.replace(/\/\*[\s\S]*?\*\//g, '');
    
    // Supprimer les commentaires de ligne
    clean = clean.replace(/\/\/.*$/gm, '');
    
    // Supprimer les blocs de description
    clean = clean.replace(/```[\s\S]*?```/g, '');
    
    // Nettoyer les espaces multiples
    clean = clean.replace(/\n\s*\n\s*\n/g, '\n\n');
    
    return clean.trim();
  }

  private analyzeCodeStructure(code: string): any {
    return {
      hasClass: code.includes('class '),
      hasExport: code.includes('export'),
      hasConstructor: code.includes('constructor'),
      hasParameters: code.includes('parameters'),
      isModuleFormat: code.includes('export') || code.includes('module.exports'),
      effectName: this.extractEffectName(code),
      category: this.extractCategory(code)
    };
  }

  private standardizeStructure(code: string, analysis: any): string {
    if (analysis.hasClass && analysis.isModuleFormat) {
      // Déjà bien structuré, juste améliorer
      return this.enhanceExistingClass(code);
    } else {
      // Créer une structure complète
      return this.createStandardClass(code, analysis);
    }
  }

  private enhanceExistingClass(code: string): string {
    // Améliorer une classe existante
    let enhanced = code;

    // S'assurer de la présence des méthodes essentielles
    if (!enhanced.includes('init(')) {
      enhanced = enhanced.replace(/constructor\([^)]*\)\s*{/, 
        `constructor(config = {}) {
        super(config);
        this.init();
    }

    init() {
        // Initialisation de l'effet`);
    }

    if (!enhanced.includes('update(')) {
      enhanced += `
    
    update(deltaTime, context) {
        // Mise à jour de l'effet
        return this;
    }`;
    }

    if (!enhanced.includes('render(')) {
      enhanced += `
    
    render(context) {
        // Rendu de l'effet
        return this;
    }`;
    }

    return enhanced;
  }

  private createStandardClass(code: string, analysis: any): string {
    const effectName = analysis.effectName || 'CustomEffect';
    const className = this.toCamelCase(effectName);

    return `/**
 * ${effectName} - Effet reconditionné et optimisé
 * Généré automatiquement par Universal Preprocessor
 */

class ${className} extends BaseEffect {
    constructor(config = {}) {
        super({
            id: '${this.generateId(effectName)}',
            name: '${effectName}',
            category: '${analysis.category || 'custom'}',
            version: '1.0',
            performance: 'optimized',
            parameters: {
                intensity: { type: 'range', min: 0, max: 1, default: 0.7 },
                speed: { type: 'range', min: 0.1, max: 2, default: 1 },
                color: { type: 'color', default: '#ffffff' }
            },
            ...config
        });

        this.init();
    }

    init() {
        // Initialisation sécurisée
        this.isInitialized = true;
        this.lastUpdate = performance.now();
        
        // Code original intégré
        ${this.integrateOriginalCode(code)}
        
        return this;
    }

    update(deltaTime, context = {}) {
        if (!this.isInitialized) return this;
        
        try {
            // Mise à jour avec protection d'erreur
            this.performUpdate(deltaTime, context);
            this.lastUpdate = performance.now();
        } catch (error) {
            console.warn('Erreur update effet:', error);
        }
        
        return this;
    }

    render(context = {}) {
        if (!this.isInitialized) return this;
        
        try {
            return this.performRender(context);
        } catch (error) {
            console.warn('Erreur render effet:', error);
            return this;
        }
    }

    performUpdate(deltaTime, context) {
        // Logique de mise à jour spécifique
    }

    performRender(context) {
        // Logique de rendu spécifique
        return this;
    }

    dispose() {
        this.isInitialized = false;
        // Nettoyage des ressources
    }
}

export default ${className};`;
  }

  private optimizePerformance(code: string): string {
    // Ajouter des optimisations de performance
    let optimized = code;
    
    // Ajouter le cache pour éviter les recalculs
    optimized = optimized.replace(/class (\w+)/, 
      `class $1 {
    constructor(config = {}) {
        super(config);
        this._cache = new Map();
        this._perfMonitor = { updates: 0, renders: 0 };`);

    // Optimiser les boucles communes
    optimized = optimized.replace(/for\s*\(\s*let\s+i\s*=\s*0/g, 
      'for (let i = 0, len = arr.length; i < len');

    return optimized;
  }

  private enhanceSecurity(code: string): string {
    // Ajouter des protections de sécurité
    let secured = code;
    
    // Valider les paramètres d'entrée
    secured = secured.replace(/constructor\([^)]*\)\s*{/, 
      `constructor(config = {}) {
        // Validation sécurisée des paramètres
        config = this.sanitizeConfig(config);`);

    // Ajouter méthode de sanitisation
    secured += `
    
    sanitizeConfig(config) {
        if (typeof config !== 'object' || config === null) {
            config = {};
        }
        // Nettoyer les propriétés dangereuses
        delete config.__proto__;
        delete config.constructor;
        return config;
    }`;

    return secured;
  }

  private formatToStandard(code: string): string {
    // Appliquer le formatage standard
    return code
      .replace(/\t/g, '    ') // Remplacer tabs par espaces
      .replace(/\n{3,}/g, '\n\n') // Max 2 lignes vides
      .replace(/;\s*}/g, ';\n}') // Aérer les fins de blocs
      .trim();
  }

  private extractMetadata(code: string, filename: string): any {
    return {
      effectName: this.extractEffectName(code) || filename.replace(/\.[^/.]+$/, ""),
      effectId: this.generateId(filename),
      category: this.extractCategory(code) || 'custom',
      version: '1.0'
    };
  }

  private generateAutoReadme(metadata: any, code: string): string {
    return `# ${metadata.effectName}

## Description
Effet JavaScript reconditionné automatiquement par Universal Preprocessor.

## Caractéristiques
- **ID**: ${metadata.effectId}  
- **Catégorie**: ${metadata.category}
- **Version**: ${metadata.version}
- **Performance**: Optimisé
- **Sécurité**: Renforcée

## Utilisation
\`\`\`javascript
const effet = new ${this.toCamelCase(metadata.effectName)}(config);
effet.init();
\`\`\`

## Structure
- Constructor avec validation
- Méthodes init(), update(), render()
- Gestion d'erreur intégrée
- Cache de performance
- Nettoyage automatique

---
*Généré automatiquement le ${new Date().toISOString()}*
`;
  }

  private extractEffectName(code: string): string {
    const nameMatch = code.match(/name\s*:\s*['"`]([^'"`]+)['"`]/);
    return nameMatch ? nameMatch[1] : null;
  }

  private extractCategory(code: string): string {
    const categoryMatch = code.match(/category\s*:\s*['"`]([^'"`]+)['"`]/);
    return categoryMatch ? categoryMatch[1] : 'custom';
  }

  private generateId(name: string): string {
    return name.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '') + '-' + Date.now();
  }

  private toCamelCase(str: string): string {
    return str.replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) => {
      return index === 0 ? word.toLowerCase() : word.toUpperCase();
    }).replace(/\s+/g, '');
  }

  private integrateOriginalCode(code: string): string {
    // Intégrer le code original de manière sécurisée
    return `// Code original intégré\n        ${code.replace(/\n/g, '\n        ')}`;
  }
}
