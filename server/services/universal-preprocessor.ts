/**
 * Module Universel de Preprocessing
 * Intercepte et normalise tout code JavaScript d'effet avant transformation
 * 
 * R√¥les :
 * 1. Extraire uniquement le code JavaScript sans descriptions
 * 2. Reconditionner au format parfait du logiciel
 */

export class UniversalPreprocessor {
  private effectMetadata: any = null;

  /**
   * Point d'entr√©e principal du preprocessing universel
   */
  async preprocessEffect(originalCode: string, filename: string): Promise<{
    cleanCode: string;
    metadata: any;
    changes: string[];
    isValid: boolean;
    error?: string;
    autoGeneratedReadme?: string; // Ajout pour le README g√©n√©r√©
  }> {
    const changes: string[] = [];

    try {
      // 1. Extraction des m√©tadonn√©es et s√©paration du code
      const extracted = this.extractCodeFromDescriptions(originalCode);
      if (extracted.hasDescriptions) {
        changes.push('Descriptions s√©par√©es du code JavaScript');
        this.effectMetadata = extracted.metadata;
      }

      // 2. Nettoyage et normalisation du code
      const cleaned = this.cleanAndNormalizeCode(extracted.code);
      if (cleaned.hasChanges) {
        changes.push(...cleaned.changes);
      }

      // 3. Auto-r√©paration du code
      const repaired = this.autoRepairCode(cleaned.code);
      if (repaired !== cleaned.code) {
        changes.push('Code auto-r√©par√©');
      }

      // 4. Injection de modules manquants
      const enhanced = this.injectMissingModules(repaired);
      if (enhanced.injectedModules.length > 0) {
        changes.push(`Modules inject√©s: ${enhanced.injectedModules.join(', ')}`);
      }

      // 5. Compatibilit√© navigateur
      const compatible = this.ensureBrowserCompatibility(enhanced.code);
      if (compatible !== enhanced.code) {
        changes.push('Compatibilit√© navigateur ajout√©e');
      }

      // 6. Correction des anti-patterns
      const optimized = this.fixPerformanceAntiPatterns(compatible);
      if (optimized.fixes.length > 0) {
        changes.push(...optimized.fixes);
      }

      // 7. G√©n√©ration d'utilitaires personnalis√©s
      const withUtilities = this.generateCustomUtilities(optimized.code);
      if (withUtilities !== optimized.code) {
        changes.push('Utilitaires personnalis√©s ajout√©s');
      }

      // 8. Application de templates intelligents
      const templated = this.applyIntelligentTemplate(withUtilities, filename);
      if (templated.hasChanges) {
        changes.push(...templated.changes);
      }

      // 9. Reconditionnement au format parfait
      const formatted = this.formatToStandardStructure(templated.code, filename);
      if (formatted.hasChanges) {
        changes.push(...formatted.changes);
      }

      // 10. Validation finale
      const validation = this.validateFinalCode(formatted.code);
      if (!validation.isValid) {
        return {
          cleanCode: originalCode,
          metadata: this.effectMetadata,
          changes: [],
          isValid: false,
          error: validation.error
        };
      }

      // Nettoyer et optimiser le code
      let result = {
        transformedCode: formatted.code,
        metadata: { ...this.effectMetadata, transformationChanges: changes },
        effectName: this.extractClassName(formatted.code) || filename.replace(/\.[^/.]+$/, ''),
        isValid: true
      };

      result.transformedCode = await this.cleanAndOptimizeCode(result.transformedCode);

      // G√©n√©rer automatiquement un README pour VariationEngine 2.0
      result.autoGeneratedReadme = this.generateEffectReadme(
        result.transformedCode,
        result.effectName
      );

      // Ajouter le README aux m√©tadonn√©es pour utilisation par d'autres modules
      result.metadata = {
        ...result.metadata,
        variationEngineReadme: result.autoGeneratedReadme,
        readmeGenerated: true,
        readmeTimestamp: new Date().toISOString()
      };

      return {
        cleanCode: result.transformedCode,
        metadata: result.metadata,
        changes,
        isValid: true,
        autoGeneratedReadme: result.autoGeneratedReadme
      };

    } catch (error) {
      return {
        cleanCode: originalCode,
        metadata: null,
        changes: [],
        isValid: false,
        error: `Erreur de preprocessing universel: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Auto-r√©paration intelligente du code
   */
  private autoRepairCode(code: string): string {
    let repairedCode = code;

    // 1. Correction des parenth√®ses/accolades manquantes
    const openParens = (repairedCode.match(/\(/g) || []).length;
    const closeParens = (repairedCode.match(/\)/g) || []).length;
    if (openParens > closeParens) {
      repairedCode += ')'.repeat(openParens - closeParens);
    }

    const openBraces = (repairedCode.match(/\{/g) || []).length;
    const closeBraces = (repairedCode.match(/\}/g) || []).length;
    if (openBraces > closeBraces) {
      repairedCode += '}'.repeat(openBraces - closeBraces);
    }

    // 2. Correction des variables non d√©clar√©es
    repairedCode = repairedCode.replace(
      /^(\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=/gm,
      (match, indent, varName) => {
        // V√©rifier si la variable est d√©j√† d√©clar√©e
        const declarationRegex = new RegExp(`(let|const|var)\\s+${varName}`, 'g');
        if (!declarationRegex.test(repairedCode)) {
          return `${indent}let ${varName} =`;
        }
        return match;
      }
    );

    // 3. Correction des fonctions malform√©es
    repairedCode = repairedCode.replace(
      /function\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(\s*\)\s*\{/g,
      'function $1() {'
    );

    // 4. Correction des m√©thodes sans this
    repairedCode = repairedCode.replace(
      /(\w+)\s*\(\s*\)\s*\{/g,
      (match, methodName) => {
        if (!match.includes('function') && !match.includes('=>')) {
          return `${methodName}() {`;
        }
        return match;
      }
    );

    return repairedCode;
  }

  /**
   * Application de templates intelligents selon le type d'effet
   */
  private applyIntelligentTemplate(code: string, filename: string): {
    code: string;
    hasChanges: boolean;
    changes: string[];
  } {
    const changes: string[] = [];
    let templatedCode = code;
    let hasChanges = false;

    // D√©tection du type d'effet
    const effectType = this.detectEffectType(code);

    // Application du template appropri√©
    switch (effectType) {
      case 'particles':
        if (!code.includes('ParticleSystem')) {
          templatedCode = this.wrapInParticleTemplate(code);
          changes.push('Template syst√®me de particules appliqu√©');
          hasChanges = true;
        }
        break;

      case 'animation':
        if (!code.includes('AnimationEngine')) {
          templatedCode = this.wrapInAnimationTemplate(code);
          changes.push('Template moteur d\'animation appliqu√©');
          hasChanges = true;
        }
        break;

      case 'canvas':
        if (!code.includes('CanvasRenderer')) {
          templatedCode = this.wrapInCanvasTemplate(code);
          changes.push('Template renderer Canvas appliqu√©');
          hasChanges = true;
        }
        break;

      case 'webgl':
        if (!code.includes('WebGLRenderer')) {
          templatedCode = this.wrapInWebGLTemplate(code);
          changes.push('Template renderer WebGL appliqu√©');
          hasChanges = true;
        }
        break;

      default:
        // Template g√©n√©rique
        if (!code.includes('class ') && !code.includes('function ')) {
          templatedCode = this.wrapInGenericTemplate(code, filename);
          changes.push('Template g√©n√©rique appliqu√©');
          hasChanges = true;
        }
    }

    return { code: templatedCode, hasChanges, changes };
  }

  /**
   * D√©tection du type d'effet
   */
  private detectEffectType(code: string): 'particles' | 'animation' | 'canvas' | 'webgl' | 'dom' | 'physics' | 'generic' {
    const patterns = {
      particles: /particle|emit|spawn|burst|spray/i,
      webgl: /webgl|shader|uniform|vertex|fragment|buffer/i,
      canvas: /canvas|context|ctx|getContext.*2d|fillRect|arc/i,
      physics: /velocity|acceleration|gravity|force|collision|bounce/i,
      animation: /animate|tween|transition|keyframe|timeline/i,
      dom: /document\.|element\.|querySelector|innerHTML|appendChild/i
    };

    for (const [type, pattern] of Object.entries(patterns)) {
      if (pattern.test(code)) {
        return type as any;
      }
    }

    return 'generic';
  }

  /**
   * Templates sp√©cialis√©s
   */
  private wrapInParticleTemplate(code: string): string {
    return `
// Syst√®me de particules optimis√©
class ParticleSystemEffect {
  constructor(container, options = {}) {
    this.container = container;
    this.options = { particleCount: 100, ...options };
    this.particles = [];
    this.pool = new ParticlePool(this.options.particleCount * 2);
    this.isRunning = false;

    this.initialize();
  }

  initialize() {
    // Code utilisateur int√©gr√©
    ${code.replace(/^/gm, '    ')}

    this.setupParticleSystem();
    this.start();
  }

  setupParticleSystem() {
    // Configuration automatique du syst√®me
    this.emitter = {
      x: this.container.width / 2,
      y: this.container.height / 2,
      rate: 10,
      lastEmit: 0
    };
  }

  update(deltaTime) {
    if (!this.isRunning) return;

    // √âmission de particules
    this.emit(deltaTime);

    // Mise √† jour des particules
    this.updateParticles(deltaTime);

    // Rendu
    this.render();
  }

  emit(deltaTime) {
    this.emitter.lastEmit += deltaTime;
    if (this.emitter.lastEmit > 1000 / this.emitter.rate) {
      const particle = this.pool.get();
      this.initializeParticle(particle);
      this.particles.push(particle);
      this.emitter.lastEmit = 0;
    }
  }

  updateParticles(deltaTime) {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const particle = this.particles[i];
      this.updateParticle(particle, deltaTime);

      if (particle.life <= 0) {
        this.particles.splice(i, 1);
        this.pool.release(particle);
      }
    }
  }

  start() {
    this.isRunning = true;
    this.animate();
  }

  stop() {
    this.isRunning = false;
  }

  animate = (currentTime = performance.now()) => {
    if (!this.isRunning) return;

    const deltaTime = currentTime - (this.lastTime || currentTime);
    this.lastTime = currentTime;

    this.update(deltaTime);
    requestAnimationFrame(this.animate);
  }
}`;
  }

  private wrapInAnimationTemplate(code: string): string {
    return `
// Moteur d'animation haute performance
class AnimationEffect {
  constructor(container, options = {}) {
    this.container = container;
    this.options = { duration: 1000, easing: 'easeInOutQuad', ...options };
    this.animations = new Map();
    this.timeline = [];
    this.isPlaying = false;

    this.initialize();
  }

  initialize() {
    // Code utilisateur int√©gr√©
    ${code.replace(/^/gm, '    ')}

    this.setupAnimationEngine();
    this.play();
  }

  setupAnimationEngine() {
    this.easingFunctions = {
      linear: t => t,
      easeInQuad: t => t * t,
      easeOutQuad: t => t * (2 - t),
      easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
    };
  }

  animate(element, properties, duration = this.options.duration, easing = this.options.easing) {
    const animation = {
      element,
      properties,
      duration,
      easing: this.easingFunctions[easing] || this.easingFunctions.linear,
      startTime: performance.now(),
      startValues: {},
      targetValues: properties
    };

    // Capture des valeurs initiales
    for (const prop in properties) {
      animation.startValues[prop] = this.getCurrentValue(element, prop);
    }

    this.animations.set(element, animation);
  }

  update(currentTime) {
    if (!this.isPlaying) return;

    for (const [element, animation] of this.animations) {
      const elapsed = currentTime - animation.startTime;
      const progress = Math.min(elapsed / animation.duration, 1);
      const easedProgress = animation.easing(progress);

      // Application des valeurs interpol√©es
      for (const prop in animation.properties) {
        const startValue = animation.startValues[prop];
        const targetValue = animation.targetValues[prop];
        const currentValue = startValue + (targetValue - startValue) * easedProgress;

        this.applyValue(element, prop, currentValue);
      }

      // Nettoyage des animations termin√©es
      if (progress >= 1) {
        this.animations.delete(element);
      }
    }

    if (this.animations.size > 0) {
      requestAnimationFrame(this.update.bind(this));
    }
  }

  play() {
    this.isPlaying = true;
    requestAnimationFrame(this.update.bind(this));
  }

  pause() {
    this.isPlaying = false;
  }
}`;
  }

  private wrapInCanvasTemplate(code: string): string {
    // Placeholder for canvas template
    return `
// Template Canvas (non impl√©ment√© dans cet exemple)
${code}
`;
  }

  private wrapInWebGLTemplate(code: string): string {
    // Placeholder for WebGL template
    return `
// Template WebGL (non impl√©ment√© dans cet exemple)
${code}
`;
  }


  private generateEffectName(filename: string): string {
    const name = filename
      .replace(/\.[^/.]+$/, '') // Remove extension
      .replace(/[^a-zA-Z0-9]/g, ' ') // Replace special chars with spaces
      .replace(/\b\w/g, l => l.toUpperCase()) // Capitalize words
      .replace(/\s/g, ''); // Remove spaces

    return name.endsWith('Effect') ? name : name + 'Effect';
  }

  /**
   * Extrait le code JavaScript pur des descriptions
   */
  private extractCodeFromDescriptions(code: string): {
    code: string;
    metadata: any;
    hasDescriptions: boolean;
  } {
    let cleanCode = code;
    let metadata = null;
    let hasDescriptions = false;

    // D√©tection des blocs de description longs (comme dans smoke-simulation)
    const descriptionBlockPattern = /export\s+const\s+(\w+)\s*=\s*{\s*id:\s*["']([^"']+)["'],?\s*name:\s*["']([^"']+)["'],?\s*description:\s*`([^`]+)`\s*([^}]*)\s*}\s*;?\s*/s;
    const match = descriptionBlockPattern.exec(code);

    if (match) {
      const [fullMatch, objectName, effectId, effectName, description, otherProps] = match;

      // Extraction des m√©tadonn√©es utiles
      metadata = {
        objectName,
        effectId,
        effectName,
        description,
        category: this.extractFromDescription(description, 'CAT√âGORIE'),
        effectType: this.extractFromDescription(description, 'EFFET DEMAND√â'),
        originalBlock: fullMatch
      };

      // Suppression du bloc de description du code
      cleanCode = code.replace(fullMatch, '');
      hasDescriptions = true;
    }

    // Nettoyage des commentaires de description excessifs
    const commentPattern = /\/\*[\s\S]*?\*\/|\/\/.*(?:\n\/\/.*)*\n/g;
    const comments = cleanCode.match(commentPattern) || [];

    if (comments.length > 0) {
      comments.forEach(comment => {
        // Garder seulement les commentaires courts et techniques
        if (comment.length > 200 || comment.includes('EFFET') || comment.includes('DESCRIPTION')) {
          cleanCode = cleanCode.replace(comment, '');
          hasDescriptions = true;
        }
      });
    }

    // Nettoyage des lignes vides excessives
    cleanCode = cleanCode.replace(/\n\s*\n\s*\n+/g, '\n\n');

    return {
      code: cleanCode.trim(),
      metadata,
      hasDescriptions
    };
  }

  /**
   * Extrait une valeur sp√©cifique de la description
   */
  private extractFromDescription(description: string, key: string): string {
    const pattern = new RegExp(`\\*\\*${key}\\s*:\\*\\*\\s*([^\\n]+)`, 'i');
    const match = pattern.exec(description);
    return match ? match[1].trim() : '';
  }

  /**
   * Nettoie et normalise le code JavaScript
   */
  private cleanAndNormalizeCode(code: string): {
    code: string;
    hasChanges: boolean;
    changes: string[];
  } {
    let cleanCode = code;
    const changes: string[] = [];
    let hasChanges = false;

    // 1. Nettoyage des exports/imports ES6
    if (/export\s+|import\s+.*from/.test(cleanCode)) {
      cleanCode = cleanCode.replace(/export\s+default\s+/g, '');
      cleanCode = cleanCode.replace(/export\s+/g, '');
      cleanCode = cleanCode.replace(/import\s+.*from\s+['"][^'"]*['"];\s*/g, '');
      changes.push('Syntaxe ES6 modules nettoy√©e');
      hasChanges = true;
    }

    // 2. Correction des erreurs de syntaxe communes
    const originalLength = cleanCode.length;
    cleanCode = this.fixCommonSyntaxErrors(cleanCode);
    if (cleanCode.length !== originalLength) {
      changes.push('Erreurs de syntaxe corrig√©es');
      hasChanges = true;
    }

    // 3. Standardisation des noms de m√©thodes
    cleanCode = cleanCode.replace(/√©mettreParticuleDepuisSource/g, 'emettreParticuleDepuisSource');
    cleanCode = cleanCode.replace(/mettre√ÄJour/g, 'mettreAJour');
    if (cleanCode !== code) {
      changes.push('Noms de m√©thodes standardis√©s');
      hasChanges = true;
    }

    return {
      code: cleanCode,
      hasChanges,
      changes
    };
  }

  /**
   * Corrige les erreurs de syntaxe communes
   */
  private fixCommonSyntaxErrors(code: string): string {
    let fixed = code;

    // Correction des espaces dans les noms de m√©thodes
    fixed = fixed.replace(/(\w+)\s+(\w+)\s*\(/g, '$1$2(');

    // Correction des caract√®res sp√©ciaux dans les identificateurs
    fixed = fixed.replace(/√©mettrePart iculeDepuisSource/g, 'emettreParticuleDepuisSource');

    // Correction des points-virgules manquants
    fixed = fixed.replace(/([^;\s}])\s*\n\s*([a-zA-Z])/g, '$1;\n$2');

    // Correction des accolades manquantes
    const openBraces = (fixed.match(/{/g) || []).length;
    const closeBraces = (fixed.match(/}/g) || []).length;
    if (openBraces > closeBraces) {
      fixed += '\n' + '}'.repeat(openBraces - closeBraces);
    }

    return fixed;
  }

  /**
   * Formate le code au format standard du logiciel
   */
  private formatToStandardStructure(code: string, filename: string): {
    code: string;
    hasChanges: boolean;
    changes: string[];
  } {
    const changes: string[] = [];
    let formattedCode = code;
    let hasChanges = false;

    // 1. Ajout de BaseEffect si n√©cessaire
    if (code.includes('extends BaseEffect') && !code.includes('class BaseEffect')) {
      const baseEffectTemplate = this.getBaseEffectTemplate();
      formattedCode = baseEffectTemplate + '\n\n' + formattedCode;
      changes.push('Classe BaseEffect ajout√©e');
      hasChanges = true;
    }

    // 2. Standardisation de la structure de classe
    if (!formattedCode.includes('initialize(') && formattedCode.includes('class ')) {
      formattedCode = this.addMissingMethods(formattedCode);
      changes.push('M√©thodes essentielles ajout√©es');
      hasChanges = true;
    }

    // 3. Ajout des exports standardis√©s
    const className = this.extractClassName(formattedCode);
    if (className && !formattedCode.includes('module.exports')) {
      formattedCode = this.addStandardExports(formattedCode, className);
      changes.push('Exports standardis√©s ajout√©s');
      hasChanges = true;
    }

    return {
      code: formattedCode,
      hasChanges,
      changes
    };
  }

  /**
   * Template de la classe BaseEffect
   */
  private getBaseEffectTemplate(): string {
    return `// Classe de base g√©n√©r√©e automatiquement
class BaseEffect {
  constructor(config = {}) {
    this.id = config.id || 'effect-' + Date.now();
    this.name = config.name || 'Effect';
    this.category = config.category || 'general';
    this.version = config.version || '1.0';
    this.performance = config.performance || 'medium';
    this.parameters = config.parameters || {};
  }

  initialize(canvas, element) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.element = element;
  }

  animate(deltaTime) {
    // M√©thode √† surcharger
  }

  destroy() {
    // Nettoyage
  }
}`;
  }

  /**
   * Ajoute les m√©thodes manquantes essentielles
   */
  private addMissingMethods(code: string): string {
    let enhanced = code;

    // Ajouter initialize si manquante
    if (!enhanced.includes('initialize(')) {
      const classMatch = enhanced.match(/class\s+\w+[^{]*{/);
      if (classMatch) {
        const insertPos = enhanced.indexOf(classMatch[0]) + classMatch[0].length;
        const initializeMethod = `
  initialize(canvas, element) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.element = element || { width: canvas.width, height: canvas.height };
  }
`;
        enhanced = enhanced.slice(0, insertPos) + initializeMethod + enhanced.slice(insertPos);
      }
    }

    // Ajouter animate si manquante
    if (!enhanced.includes('animate(')) {
      const classMatch = enhanced.match(/class\s+\w+[^{]*{/);
      if (classMatch) {
        const insertPos = enhanced.indexOf(classMatch[0]) + classMatch[0].length;
        const animateMethod = `
  animate(deltaTime = 16) {
    if (!this.ctx || !this.canvas) return;
    // Animation par d√©faut
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
`;
        enhanced = enhanced.slice(0, insertPos) + animateMethod + enhanced.slice(insertPos);
      }
    }

    return enhanced;
  }

  /**
   * Extrait le nom de la classe principale
   */
  private extractClassName(code: string): string | null {
    const classMatch = code.match(/class\s+(\w+)/);
    return classMatch ? classMatch[1] : null;
  }

  /**
   * Ajoute les exports standardis√©s
   */
  private addStandardExports(code: string, className: string): string {
    const exportCode = `

// Export pour utilisation
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ${className};
}

// Usage autonome si charg√© directement  
if (typeof window !== 'undefined') {
  window.${className} = ${className};

  // Fonction utilitaire pour d√©marrage rapide
  window.start${className} = function(canvasId, config = {}) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) {
      console.error('Canvas non trouv√©:', canvasId);
      return null;
    }

    const effect = new ${className}(config);
    effect.initialize(canvas, { 
      width: canvas.width, 
      height: canvas.height 
    });

    let lastTime = 0;
    const animationLoop = (currentTime) => {
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;

      effect.animate(deltaTime);
      requestAnimationFrame(animationLoop);
    };

    requestAnimationFrame(animationLoop);
    return effect;
  };
}`;

    return code + exportCode;
  }

  /**
   * Validation finale du code nettoy√©
   */
  private validateFinalCode(code: string): { isValid: boolean; error?: string } {
    try {
      // Pr√©paration du code pour validation
      let validationCode = code;

      // Remplacement temporaire des template literals complexes
      validationCode = validationCode.replace(/`[\s\S]*?`/g, '"TEMPLATE_LITERAL"');

      // Remplacement temporaire des regex complexes
      validationCode = validationCode.replace(/\/[^\/\n]+\/[gimuy]*/g, '/REGEX/');

      // Test de syntaxe basique
      new Function(validationCode);
      return { isValid: true };
    } catch (error) {
      return {
        isValid: false,
        error: `Code JavaScript invalide apr√®s preprocessing: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * D√©tecte et injecte automatiquement les modules manquants
   */
  private injectMissingModules(code: string): {
    code: string;
    injectedModules: string[];
  } {
    const injectedModules: string[] = [];
    let enhancedCode = code;

    // D√©tection de besoins sp√©cifiques
    const needsAnimationFrameManager = /requestAnimationFrame|animate/i.test(code);
    const needsPerformanceMonitor = /performance|fps|benchmark/i.test(code);
    const needsResizeHandler = /resize|viewport|window\.(width|height)/i.test(code);
    const needsPointerManager = /mouse|touch|pointer|click|drag/i.test(code);
    const needsMathUtils = /Math\.(sin|cos|random|sqrt|pow)/i.test(code);
    const needsColorUtils = /color|rgb|hsl|hex|gradient/i.test(code);

    // Injection automatique si n√©cessaire
    if (needsAnimationFrameManager && !code.includes('AnimationFrameManager')) {
      enhancedCode = this.injectAnimationFrameManager() + '\n\n' + enhancedCode;
      injectedModules.push('AnimationFrameManager');
    }

    if (needsPerformanceMonitor && !code.includes('PerformanceMonitor')) {
      enhancedCode = this.injectPerformanceMonitor() + '\n\n' + enhancedCode;
      injectedModules.push('PerformanceMonitor');
    }

    if (needsResizeHandler && !code.includes('ResizeHandler')) {
      enhancedCode = this.injectResizeHandler() + '\n\n' + enhancedCode;
      injectedModules.push('ResizeHandler');
    }

    if (needsPointerManager && !code.includes('PointerManager')) {
      enhancedCode = this.injectPointerManager() + '\n\n' + enhancedCode;
      injectedModules.push('PointerManager');
    }

    if (needsMathUtils && !code.includes('MathUtils')) {
      enhancedCode = this.injectMathUtils() + '\n\n' + enhancedCode;
      injectedModules.push('MathUtils');
    }

    if (needsColorUtils && !code.includes('ColorUtils')) {
      enhancedCode = this.injectColorUtils() + '\n\n' + enhancedCode;
      injectedModules.push('ColorUtils');
    }

    return { code: enhancedCode, injectedModules };
  }

  /**
   * Syst√®me de compatibilit√© navigateur automatique
   */
  private ensureBrowserCompatibility(code: string): string {
    let compatibleCode = code;

    // Polyfills automatiques
    if (code.includes('requestAnimationFrame') && !code.includes('window.requestAnimationFrame')) {
      compatibleCode = `
// Polyfill requestAnimationFrame
window.requestAnimationFrame = window.requestAnimationFrame || 
  window.webkitRequestAnimationFrame || 
  window.mozRequestAnimationFrame || 
  function(callback) { return setTimeout(callback, 1000/60); };

${compatibleCode}`;
    }

    // Support WebGL avec fallback Canvas
    if (code.includes('getContext(\'webgl\'')) {
      compatibleCode = compatibleCode.replace(
        /getContext\('webgl'\)/g,
        `getContext('webgl') || getContext('experimental-webgl') || getContext('2d')`
      );
    }

    return compatibleCode;
  }

  /**
   * D√©tection et correction des patterns anti-performance
   */
  private fixPerformanceAntiPatterns(code: string): {
    code: string;
    fixes: string[];
  } {
    let fixedCode = code;
    const fixes: string[] = [];

    // Correction des boucles dans render
    if (code.includes('for (') && code.includes('render')) {
      fixedCode = fixedCode.replace(
        /(render[^{]*{[^}]*)(for\s*\([^)]+\)\s*{[^}]+})/g,
        '$1// Optimis√©: boucle mise en cache\nif (!this._cachedLoop) { $2 this._cachedLoop = true; }'
      );
      fixes.push('Optimisation des boucles en render');
    }

    // Cache des calculs r√©p√©titifs
    if (code.includes('Math.sin') || code.includes('Math.cos')) {
      fixedCode = `
// Cache trigonom√©trique automatique
const TrigCache = {
  cache: new Map(),
  sin: (angle) => {
    if (!TrigCache.cache.has(angle)) {
      TrigCache.cache.set(angle, Math.sin(angle));
    }
    return TrigCache.cache.get(angle);
  },
  cos: (angle) => {
    if (!TrigCache.cache.has('cos_' + angle)) {
      TrigCache.cache.set('cos_' + angle, Math.cos(angle));
    }
    return TrigCache.cache.get('cos_' + angle);
  }
};

${fixedCode.replace(/Math\.sin/g, 'TrigCache.sin').replace(/Math\.cos/g, 'TrigCache.cos')}`;
      fixes.push('Cache trigonom√©trique ajout√©');
    }

    return { code: fixedCode, fixes };
  }

  /**
   * G√©n√©ration de m√©thodes utilitaires personnalis√©es
   */
  private generateCustomUtilities(code: string): string {
    let enhancedCode = code;

    // Si l'effet utilise des particules, ajouter un gestionnaire
    if (/particle|emit|spawn/i.test(code)) {
      enhancedCode = `
// Gestionnaire de particules optimis√©
class ParticlePool {
  constructor(size = 1000) {
    this.pool = [];
    this.active = [];
    for (let i = 0; i < size; i++) {
      this.pool.push(this.createParticle());
    }
  }

  createParticle() {
    return { x: 0, y: 0, vx: 0, vy: 0, life: 1, active: false };
  }

  get() {
    return this.pool.pop() || this.createParticle();
  }

  release(particle) {
    particle.active = false;
    this.pool.push(particle);
  }
}

${enhancedCode}`;
    }

    return enhancedCode;
  }

  /**
   * Nettoie et optimise le code JavaScript
   */
  private async cleanAndOptimizeCode(code: string): Promise<string> {
    // Ici, vous pourriez int√©grer des outils comme Terser ou UglifyJS pour une optimisation plus pouss√©e
    // Pour l'instant, nous faisons un nettoyage simple.
    let optimizedCode = code.trim();

    // Supprimer les commentaires inutiles (en gardant les commentaires JSDoc si n√©cessaire)
    optimizedCode = optimizedCode.replace(/\/\*[\s\S]*?\*\/|\/\/[^\n]*\n/g, (match) => {
      if (match.startsWith('/**')) { // Garder les commentaires JSDoc
        return match;
      }
      return '';
    });

    // Supprimer les lignes vides multiples
    optimizedCode = optimizedCode.replace(/\n\s*\n+/g, '\n');

    // Remplacer les noms de variables locales si possible (complexit√© √©lev√©e)
    // Pour l'instant, cette √©tape est omise pour des raisons de simplicit√©.

    return optimizedCode;
  }


  // M√©thodes d'injection des modules
  private injectAnimationFrameManager(): string {
    return `
// Gestionnaire d'animation optimis√©
class AnimationFrameManager {
  constructor() {
    this.callbacks = new Set();
    this.isRunning = false;
    this.lastTime = 0;
    this.deltaTime = 0;
  }

  add(callback) {
    this.callbacks.add(callback);
    if (!this.isRunning) this.start();
  }

  remove(callback) {
    this.callbacks.delete(callback);
    if (this.callbacks.size === 0) this.stop();
  }

  start() {
    this.isRunning = true;
    this.lastTime = performance.now();
    this.tick();
  }

  tick = (currentTime = performance.now()) => {
    this.deltaTime = currentTime - this.lastTime;
    this.lastTime = currentTime;

    this.callbacks.forEach(callback => callback(this.deltaTime));

    if (this.isRunning) {
      requestAnimationFrame(this.tick);
    }
  }

  stop() {
    this.isRunning = false;
  }
}`;
  }

  private injectPerformanceMonitor(): string {
    return `
// Moniteur de performance automatique
class PerformanceMonitor {
  constructor() {
    this.frameCount = 0;
    this.lastTime = performance.now();
    this.fps = 60;
    this.frameTime = 16.67;
  }

  update() {
    const now = performance.now();
    this.frameTime = now - this.lastTime;
    this.lastTime = now;
    this.frameCount++;

    if (this.frameCount % 60 === 0) {
      this.fps = Math.round(1000 / this.frameTime);
      if (this.fps < 30) {
        this.onPerformanceIssue?.();
      }
    }
  }

  getFPS() { return this.fps; }
  getFrameTime() { return this.frameTime; }
}`;
  }

  private injectMathUtils(): string {
    return `
// Utilitaires math√©matiques optimis√©s
class MathUtils {
  static lerp(a, b, t) { return a + (b - a) * t; }
  static clamp(value, min, max) { return Math.min(Math.max(value, min), max); }
  static map(value, inMin, inMax, outMin, outMax) {
    return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
  }
  static distance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
  }
  static angle(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
  static randomBetween(min, max) {
    return Math.random() * (max - min) + min;
  }
}`;
  }

  private injectColorUtils(): string {
    return `
// Utilitaires de couleur
class ColorUtils {
  static hexToRgb(hex) {
    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  static rgbToHsl(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }

    return { h: h * 360, s: s * 100, l: l * 100 };
  }

  static interpolateColors(color1, color2, factor) {
    const rgb1 = this.hexToRgb(color1);
    const rgb2 = this.hexToRgb(color2);

    return {
      r: Math.round(rgb1.r + (rgb2.r - rgb1.r) * factor),
      g: Math.round(rgb1.g + (rgb2.g - rgb1.g) * factor),
      b: Math.round(rgb1.b + (rgb2.b - rgb1.b) * factor)
    };
  }
}`;
  }

  private injectResizeHandler(): string {
    return `
// Gestionnaire de redimensionnement optimis√©
class ResizeHandler {
  constructor(callback, debounceTime = 100) {
    this.callback = callback;
    this.debounceTime = debounceTime;
    this.timeoutId = null;
    this.currentSize = { width: window.innerWidth, height: window.innerHeight };

    window.addEventListener('resize', this.handleResize);
  }

  handleResize = () => {
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      const newSize = { width: window.innerWidth, height: window.innerHeight };
      if (newSize.width !== this.currentSize.width || newSize.height !== this.currentSize.height) {
        this.currentSize = newSize;
        this.callback(newSize);
      }
    }, this.debounceTime);
  }

  destroy() {
    window.removeEventListener('resize', this.handleResize);
    clearTimeout(this.timeoutId);
  }
}`;
  }

  private injectPointerManager(): string {
    return `
// Gestionnaire d'√©v√©nements pointer unifi√©
class PointerManager {
  constructor(element) {
    this.element = element;
    this.pointers = new Map();
    this.callbacks = {
      down: new Set(),
      move: new Set(),
      up: new Set()
    };

    this.setupListeners();
  }

  setupListeners() {
    const events = ['mousedown', 'touchstart'];
    events.forEach(event => {
      this.element.addEventListener(event, this.handlePointerDown);
    });

    const moveEvents = ['mousemove', 'touchmove'];
    moveEvents.forEach(event => {
      document.addEventListener(event, this.handlePointerMove);
    });

    const upEvents = ['mouseup', 'touchend', 'touchcancel'];
    upEvents.forEach(event => {
      document.addEventListener(event, this.handlePointerUp);
    });
  }

  handlePointerDown = (e) => {
    e.preventDefault();
    const pointer = this.getPointerInfo(e);
    this.pointers.set(pointer.id, pointer);
    this.callbacks.down.forEach(cb => cb(pointer));
  }

  handlePointerMove = (e) => {
    const pointer = this.getPointerInfo(e);
    if (this.pointers.has(pointer.id)) {
      this.pointers.set(pointer.id, pointer);
      this.callbacks.move.forEach(cb => cb(pointer));
    }
  }

  handlePointerUp = (e) => {
    const pointer = this.getPointerInfo(e);
    if (this.pointers.has(pointer.id)) {
      this.pointers.delete(pointer.id);
      this.callbacks.up.forEach(cb => cb(pointer));
    }
  }

  getPointerInfo(e) {
    const rect = this.element.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0]?.clientX || e.changedTouches[0]?.clientX : e.clientX;
    const clientY = e.touches ? e.touches[0]?.clientY || e.changedTouches[0]?.clientY : e.clientY;

    return {
      id: e.touches ? e.touches[0]?.identifier || 0 : 'mouse',
      x: clientX - rect.left,
      y: clientY - rect.top,
      clientX,
      clientY,
      type: e.type.includes('touch') ? 'touch' : 'mouse'
    };
  }

  on(event, callback) {
    this.callbacks[event]?.add(callback);
  }

  off(event, callback) {
    this.callbacks[event]?.delete(callback);
  }
}`;
  }

  /**
   * R√©cup√®re les m√©tadonn√©es extraites
   */
  getExtractedMetadata(): any {
    return this.effectMetadata;
  }

  /**
   * Analyse un README associ√© pour enrichir les m√©tadonn√©es
   */
  analyzeAssociatedReadme(readmeContent: string): any {
    if (!readmeContent) return null;

    try {
      // Import dynamique pour √©viter les d√©pendances circulaires
      const { ReadmeAnalyzer } = require('./readme-analyzer');
      const analyzer = new ReadmeAnalyzer();

      const readmeAnalysis = analyzer.analyzeReadme(readmeContent);
      const variationSuggestions = analyzer.generateVariationSuggestions(readmeAnalysis);

      return {
        readmeAnalysis,
        variationSuggestions,
        enhancementPotential: this.calculateEnhancementPotential(readmeAnalysis),
        intelligentAdaptations: this.generateIntelligentAdaptations(readmeAnalysis)
      };
    } catch (error) {
      console.warn('Erreur lors de l\'analyse du README:', error);
      return null;
    }
  }

  /**
   * Calcule le potentiel d'am√©lioration bas√© sur l'analyse README
   */
  private calculateEnhancementPotential(analysis: any): any {
    const potential = {
      parameterOptimization: analysis.parameters.length * 0.15, // 15% par param√®tre
      typeVariations: analysis.effectTypes.length * 0.10, // 10% par type
      applicationOptimizations: analysis.applications.length * 0.08, // 8% par application
      scientificAccuracy: analysis.scientificBasis ? 0.25 : 0, // 25% si base scientifique
      total: 0
    };

    potential.total = Math.min(
      potential.parameterOptimization +
      potential.typeVariations +
      potential.applicationOptimizations +
      potential.scientificAccuracy,
      1.0
    );

    return potential;
  }

  /**
   * G√©n√®re des adaptations intelligentes
   */
  private generateIntelligentAdaptations(analysis: any): any[] {
    const adaptations = [];

    // Adaptations bas√©es sur les contraintes physiques
    if (analysis.physicalConstraints && analysis.physicalConstraints.equations) {
      adaptations.push({
        type: 'physics_optimization',
        description: 'Optimisation des calculs physiques',
        impact: 'Am√©lioration performance + r√©alisme',
        equations: analysis.physicalConstraints.equations.length
      });
    }

    // Adaptations bas√©es sur les param√®tres
    if (analysis.parameters.length > 0) {
      adaptations.push({
        type: 'parameter_intelligence',
        description: `Gestion intelligente de ${analysis.parameters.length} param√®tres`,
        impact: 'Contr√¥le pr√©cis et variations automatiques',
        parameters: analysis.parameters.map(p => p.name)
      });
    }

    // Adaptations bas√©es sur les applications
    if (analysis.applications.length > 0) {
      adaptations.push({
        type: 'application_specific',
        description: `Optimisations sp√©cifiques pour ${analysis.applications.length} applications`,
        impact: 'Performance adapt√©e au contexte d\'usage',
        applications: analysis.applications
      });
    }

    return adaptations;
  }

  /**
   * Injection automatique du syst√®me de debug
   */
  private injectDebugSystem(code: string): string {
    return `
// Syst√®me de debug int√©gr√©
class EffectDebugger {
  constructor(effectName = 'Effect') {
    this.effectName = effectName;
    this.isEnabled = localStorage.getItem('effectDebug') === 'true' || window.location.hash.includes('debug');
    this.metrics = {
      frameCount: 0,
      averageFPS: 0,
      memoryUsage: 0,
      renderTime: 0
    };
    this.lastFrameTime = performance.now();

    if (this.isEnabled) {
      this.createDebugPanel();
    }
  }

  log(message, ...args) {
    if (this.isEnabled) {
      console.log(\`[\${this.effectName}]\`, message, ...args);
    }
  }

  warn(message, ...args) {
    if (this.isEnabled) {
      console.warn(\`[\${this.effectName}]\`, message, ...args);
    }
  }

  error(message, ...args) {
    console.error(\`[\${this.effectName}]\`, message, ...args);
  }

  time(label) {
    if (this.isEnabled) {
      console.time(\`[\${this.effectName}] \${label}\`);
    }
  }

  timeEnd(label) {
    if (this.isEnabled) {
      console.timeEnd(\`[\${this.effectName}] \${label}\`);
    }
  }

  updateMetrics() {
    const now = performance.now();
    const frameTime = now - this.lastFrameTime;
    this.lastFrameTime = now;

    this.metrics.frameCount++;
    this.metrics.renderTime = frameTime;

    if (this.metrics.frameCount % 60 === 0) {
      this.metrics.averageFPS = Math.round(1000 / frameTime);

      if (performance.memory) {
        this.metrics.memoryUsage = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
      }

      if (this.isEnabled) {
        this.updateDebugPanel();
      }
    }
  }

  createDebugPanel() {
    const panel = document.createElement('div');
    panel.id = 'effect-debug-panel';
    panel.style.cssText = \`
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
      border-radius: 5px;
      z-index: 9999;
      min-width: 200px;
    \`;
    document.body.appendChild(panel);
  }

  updateDebugPanel() {
    const panel = document.getElementById('effect-debug-panel');
    if (panel) {
      panel.innerHTML = \`
        <div><strong>\${this.effectName} Debug</strong></div>
        <div>FPS: \${this.metrics.averageFPS}</div>
        <div>Frame Time: \${this.metrics.renderTime.toFixed(2)}ms</div>
        <div>Memory: \${this.metrics.memoryUsage}MB</div>
        <div>Frames: \${this.metrics.frameCount}</div>
        <div><button onclick="this.parentElement.remove()">Close</button></div>
      \`;
    }
  }
}

${code}`;
  }

  /**
   * R√©initialise le preprocessor
   */
  reset(): void {
    this.effectMetadata = null;
  }

  // --- Fonctions pour la g√©n√©ration automatique de README ---

  /**
   * G√©n√®re automatiquement un README d√©taill√© pour aider le VariationEngine 2.0
   * √† mieux comprendre et optimiser l'effet
   */
  generateEffectReadme(code: string, effectName?: string): string {
    try {
      // Analyse du code pour extraire des informations
      const analysis = this.analyzeEffectCode(code);
      const extractedName = effectName || analysis.name || 'UnknownEffect';

      return `# ${analysis.emoji} ${extractedName}

## Description

${analysis.description}

## Fichiers

- \`${extractedName.toLowerCase()}.js\` - Script JavaScript principal de l'effet
- \`Description.txt\` - Documentation technique compl√®te et sp√©cifications
- \`README.txt\` - Ce fichier d'information

## Caract√©ristiques Techniques

- **ID Unique**: ${analysis.id}
- **Cat√©gorie**: ${analysis.category}
- **Type**: ${analysis.type}
- **Performance**: ${analysis.performance}

## Param√®tres Configurables

${analysis.parameters.map((param, index) =>
  `${index + 1}. **${param.name}** (${param.range}) - ${param.description}`
).join('\n')}

## Types de Variations Disponibles

${analysis.variations.map(variation =>
  `- **${variation.name}** - ${variation.description} (${variation.specs})`
).join('\n')}

## Fonctionnalit√©s Avanc√©es

${analysis.features.map(feature => `- ${feature}`).join('\n')}

## Bases Scientifiques

${analysis.scientificBasis && analysis.scientificBasis.length > 0 ?
  `L'effet s'appuie sur des mod√®les physiques authentiques :\n${analysis.scientificBasis.map(basis => `- ${basis}`).join('\n')}` :
  'L\'effet utilise des algorithmes optimis√©s pour des performances maximales.'
}

## Utilisation

\`\`\`javascript
import ${extractedName} from './${extractedName.toLowerCase()}.js';

const effect = new ${extractedName}({
${analysis.parameters.slice(0, 6).map(param =>
  `    ${param.name.toLowerCase()}: ${param.defaultValue},`
).join('\n')}
});

effect.initialize(canvas, element);
effect.start();
\`\`\`

## Ph√©nom√®nes Simul√©s

${analysis.phenomena.map(phenomenon => `- **${phenomenon.name}** - ${phenomenon.description}`).join('\n')}

## Optimisations VariationEngine 2.0

Cette documentation d√©taill√©e permet au VariationEngine 2.0 de :
- üéØ **Identifier les param√®tres cl√©s** pour g√©n√©rer des variations pertinentes
- üî¨ **Comprendre la base scientifique** pour respecter la physique de l'effet
- üé® **Cr√©er des variations coh√©rentes** bas√©es sur les types disponibles
- ‚ö° **Optimiser les performances** selon les caract√©ristiques techniques
- üß¨ **Appliquer des mutations intelligentes** sur les param√®tres configurables

---

*README g√©n√©r√© automatiquement pour optimisation VariationEngine 2.0*`;

    } catch (error) {
      console.error('Erreur g√©n√©ration README:', error);
      return this.generateFallbackReadme(effectName || 'Effect');
    }
  }

  /**
   * Analyse le code JavaScript pour extraire des informations pertinentes
   */
  private analyzeEffectCode(code: string): any {
    // D√©tection du nom et de l'emoji
    const nameMatch = code.match(/name:\s*['"](.*?)['"]/) ||
                     code.match(/class\s+(\w+)/) ||
                     code.match(/function\s+(\w+)/) ||
                     code.match(/const\s+(\w+)/);

    const name = nameMatch ? nameMatch[1] : 'VisualEffect';

    // D√©tection de l'emoji et cat√©gorie
    let emoji = '‚ú®';
    let category = 'Visuel';
    let type = 'Effet dynamique';

    if (code.includes('particle') || code.includes('Particle')) {
      emoji = 'üéÜ';
      category = 'Particules';
      type = 'Syst√®me de particules';
    } else if (code.includes('smoke') || code.includes('Smoke')) {
      emoji = 'üí®';
      category = 'Simulation';
      type = 'Simulation fluide';
    } else if (code.includes('fire') || code.includes('Fire')) {
      emoji = 'üî•';
      category = 'Combustion';
      type = 'Simulation thermodynamique';
    } else if (code.includes('water') || code.includes('Water')) {
      emoji = 'üåä';
      category = 'Fluide';
      type = 'Simulation hydraulique';
    } else if (code.includes('explosion') || code.includes('Explosion')) {
      emoji = 'üí•';
      category = 'Explosion';
      type = 'Simulation pyrotechnique';
    } else if (code.includes('glow') || code.includes('Glow')) {
      emoji = '‚ú®';
      category = 'Lumineux';
      type = 'Effet lumineux';
    }

    // Extraction des param√®tres
    const parameters = this.extractParameters(code);

    // G√©n√©ration des variations sugg√©r√©es
    const variations = this.generateVariationSuggestions(category, type);

    // Extraction des fonctionnalit√©s
    const features = this.extractFeatures(code);

    // Bases scientifiques selon la cat√©gorie
    const scientificBasis = this.getScientificBasis(category);

    // Ph√©nom√®nes simul√©s
    const phenomena = this.extractPhenomena(code, category);

    return {
      name,
      emoji,
      category,
      type,
      id: `${category.toLowerCase()}-${name.toLowerCase()}-${Date.now().toString().slice(-3)}`,
      performance: this.assessPerformance(code),
      description: this.generateDescription(name, category, type),
      parameters,
      variations,
      features,
      scientificBasis,
      phenomena
    };
  }

  private extractParameters(code: string): any[] {
    const commonParams = [
      { name: 'Intensit√©', range: '0.1-10.0', description: 'Force de l\'effet', defaultValue: '1.0' },
      { name: 'Vitesse', range: '0.1-5.0', description: 'Vitesse d\'animation', defaultValue: '1.0' },
      { name: 'Taille', range: '0.5-3.0', description: '√âchelle de l\'effet', defaultValue: '1.0' },
      { name: 'Opacit√©', range: '0.0-1.0', description: 'Transparence g√©n√©rale', defaultValue: '0.8' },
      { name: 'Couleur', range: 'RGB/HSL', description: 'Palette de couleurs', defaultValue: '#ffffff' },
      { name: 'Qualit√©', range: '1-10', description: 'Niveau de d√©tail', defaultValue: '5' }
    ];

    // Param√®tres sp√©cifiques selon le type d'effet
    if (code.includes('particle') || code.includes('Particle')) {
      commonParams.push(
        { name: 'Nombre', range: '10-1000', description: 'Nombre de particules', defaultValue: '200' },
        { name: 'Gravit√©', range: '-10-10', description: 'Force gravitationnelle', defaultValue: '0.1' }
      );
    }

    if (code.includes('smoke') || code.includes('Smoke')) {
      commonParams.push(
        { name: 'Densit√©', range: '0.1-5.0', description: 'Concentration de fum√©e', defaultValue: '1.5' },
        { name: 'Temp√©rature', range: '300-1500', description: 'Chaleur du fluide', defaultValue: '600' },
        { name: 'Turbulence', range: '0-1', description: 'Niveau de chaos', defaultValue: '0.4' }
      );
    }

    return commonParams;
  }

  private generateVariationSuggestions(category: string, type: string): any[] {
    const baseVariations = [
      { name: 'L√©ger', description: 'Version optimis√©e performance', specs: 'Performance+, Qualit√©-' },
      { name: 'Standard', description: '√âquilibre optimal', specs: 'Performance=, Qualit√©=' },
      { name: 'Premium', description: 'Qualit√© maximale', specs: 'Performance-, Qualit√©+' }
    ];

    if (category === 'Simulation') {
      baseVariations.push(
        { name: 'R√©aliste', description: 'Simulation physique compl√®te', specs: 'Physique+, Performance-' },
        { name: 'Stylis√©', description: 'Rendu artistique', specs: 'Cr√©ativit√©+, Physique-' }
      );
    }

    if (category === 'Particules') {
      baseVariations.push(
        { name: 'Essaim', description: 'Nombreuses petites particules', specs: 'Nombre+, Taille-' },
        { name: 'Macro', description: 'Peu de grosses particules', specs: 'Nombre-, Taille+' }
      );
    }

    return baseVariations;
  }

  private extractFeatures(code: string): string[] {
    const features = [];

    if (code.includes('canvas') || code.includes('Canvas')) {
      features.push('Rendu Canvas 2D/3D optimis√©');
    }

    if (code.includes('requestAnimationFrame') || code.includes('RAF')) {
      features.push('Animation fluide 60 FPS');
    }

    if (code.includes('physics') || code.includes('Physics')) {
      features.push('Simulation physique r√©aliste');
    }

    if (code.includes('responsive') || code.includes('Responsive')) {
      features.push('Adaptation responsive automatique');
    }

    if (code.includes('performance') || code.includes('Performance')) {
      features.push('Optimisations de performance avanc√©es');
    }

    // Ajouter des fonctionnalit√©s par d√©faut
    features.push(
      'Contr√¥les interactifs (start/pause/reset)',
      'Configuration param√©trable en temps r√©el',
      'Compatibilit√© cross-browser garantie',
      'API √©v√©nementielle compl√®te',
      'Gestion d\'erreurs robuste'
    );

    return features;
  }

  private getScientificBasis(category: string): string[] {
    const bases = {
      'Simulation': [
        'M√©canique des fluides (√©quations Navier-Stokes)',
        'Thermodynamique (transferts chaleur, changements phase)',
        'Physique des particules (dynamiques, collisions)',
        'Math√©matiques appliqu√©es (calcul diff√©rentiel, alg√®bre lin√©aire)'
      ],
      'Particules': [
        'Dynamique des corps rigides',
        'Syst√®mes de particules (√©mission, √©volution, extinction)',
        'Forces physiques (gravit√©, friction, magn√©tisme)',
        'Th√©orie du chaos (comportements √©mergents)'
      ],
      'Lumineux': [
        'Optique g√©om√©trique et ondulatoire',
        'Photom√©trie (intensit√©, flux lumineux)',
        'Colorim√©trie (espaces colorim√©triques, perception)',
        'Ph√©nom√®nes de diffraction et r√©fraction'
      ]
    };

    return bases[category] || [
      'Algorithmes optimis√©s pour performances temps r√©el',
      'Math√©matiques computationnelles avanc√©es',
      'Th√©orie des graphiques et animation proc√©durale'
    ];
  }

  private extractPhenomena(code: string, category: string): any[] {
    const phenomena = [];

    if (category === 'Simulation') {
      phenomena.push(
        { name: 'Convection', description: 'Mouvements fluides par diff√©rences de temp√©rature' },
        { name: 'Diffusion', description: 'Propagation mol√©culaire dans l\'espace' },
        { name: 'Turbulence', description: '√âcoulements chaotiques multi-√©chelles' }
      );
    } else if (category === 'Particules') {
      phenomena.push(
        { name: '√âmission', description: 'G√©n√©ration contr√¥l√©e de nouvelles particules' },
        { name: '√âvolution', description: 'Transformation des propri√©t√©s au cours du temps' },
        { name: 'Interaction', description: 'Forces entre particules et environnement' }
      );
    } else {
      phenomena.push(
        { name: 'Animation', description: 'Interpolation fluide des propri√©t√©s visuelles' },
        { name: 'Rendu', description: 'Optimisation du pipeline graphique' },
        { name: 'Interactivit√©', description: 'R√©ponse aux √©v√©nements utilisateur' }
      );
    }

    return phenomena;
  }

  private assessPerformance(code: string): string {
    let score = 0;

    if (code.includes('requestAnimationFrame')) score += 2;
    if (code.includes('performance') || code.includes('optimize')) score += 2;
    if (code.includes('cache') || code.includes('buffer')) score += 1;
    if (code.includes('webgl') || code.includes('WebGL')) score += 3;
    if (code.length < 5000) score += 1;
    if (code.includes('worker') || code.includes('Worker')) score += 2;

    if (score >= 7) return 'Tr√®s Haute (optimis√© pour animations complexes)';
    if (score >= 5) return 'Haute (optimis√© pour performances temps r√©el)';
    if (score >= 3) return 'Moyenne (bon √©quilibre qualit√©/performance)';
    return 'Standard (fonctionnel sur tous appareils)';
  }

  private generateDescription(name: string, category: string, type: string): string {
    const descriptions = {
      'Simulation': `Effet sp√©cial avanc√© qui simule des ph√©nom√®nes physiques r√©alistes avec des mod√®les math√©matiques authentiques. L'animation reproduit fid√®lement les lois de la physique avec des √©quations diff√©rentielles, la thermodynamique, et des interactions particule-fluide complexes.`,
      'Particules': `Syst√®me de particules sophistiqu√© g√©n√©rant des animations dynamiques avec comportements √©mergents. Chaque particule ob√©it √† des lois physiques individuelles tout en contribuant √† un effet d'ensemble coh√©rent et spectaculaire.`,
      'Lumineux': `Effet lumineux avanc√© exploitant les principes optiques pour cr√©er des jeux de lumi√®re r√©alistes. L'animation simule la propagation photonique, les r√©flexions, r√©fractions et ph√©nom√®nes de diffusion lumineuse.`
    };

    return descriptions[category] || `Effet visuel ${type.toLowerCase()} optimis√© par intelligence artificielle. L'animation combine algorithmes avanc√©s et rendu temps r√©el pour une exp√©rience visuelle immersive et performante.`;
  }

  private generateFallbackReadme(effectName: string): string {
    return `# ‚ú® ${effectName}

## Description

Effet visuel JavaScript optimis√© par intelligence artificielle.

## Utilisation

\`\`\`javascript
const effect = new ${effectName}();
effect.initialize(canvas);
effect.start();
\`\`\`

## Fonctionnalit√©s

- Animation fluide et optimis√©e
- Compatible tous navigateurs
- API simple et intuitive
- Performance adaptative

---

*G√©n√©r√© automatiquement pour VariationEngine 2.0*`;
  }
}