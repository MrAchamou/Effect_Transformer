
/**
 * Test du syst√®me de reconditionnement universel
 * Teste la transformation d'un effet basique vers une structure parfaite
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function testUniversalReconditioning() {
  console.log('üîÑ === TEST DU RECONDITIONNEMENT UNIVERSEL ===\n');

  try {
    // 1. Import dynamique du preprocessor
    const { UniversalPreprocessor } = await import('./services/universal-preprocessor.js');

    // 2. Charger l'effet de simulation de fum√©e
    const smokeEffectPath = path.join(__dirname, '..', 'attached_assets', 'smoke-simulation_1755795417492.js');

    if (!fs.existsSync(smokeEffectPath)) {
      console.log('‚ùå Fichier effet fum√©e non trouv√©, utilisation d\'un code de test');
      
      // Code de test simple pour d√©monstration
      const testCode = `
// Effet simple pour test
const simpleEffect = {
  id: "test-effect-001",
  name: "Effet de Test Simple",
  
  init: function() {
    this.particles = [];
    for (let i = 0; i < 50; i++) {
      this.particles.push({
        x: Math.random() * 800,
        y: Math.random() * 600,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4,
        life: 1.0
      });
    }
  },
  
  update: function(deltaTime) {
    for (let particle of this.particles) {
      particle.x += particle.vx * deltaTime;
      particle.y += particle.vy * deltaTime;
      particle.life -= deltaTime * 0.01;
    }
  }
};
`;

      await testEffectReconditioning(testCode, 'simple-test-effect.js');
      return;
    }

    const originalCode = fs.readFileSync(smokeEffectPath, 'utf8');
    console.log('üìÑ Code original charg√©:', originalCode.length, 'caract√®res');

    await testEffectReconditioning(originalCode, 'smoke-simulation.js');

  } catch (error) {
    console.error('‚ùå Erreur lors du test:', error.message);
    console.error('Stack:', error.stack);
  }
}

async function testEffectReconditioning(originalCode, filename) {
  try {
    // Import dynamique du preprocessor
    const { UniversalPreprocessor } = await import('./services/universal-preprocessor.js');
    
    // Initialiser le preprocessor
    const preprocessor = new UniversalPreprocessor();

    // Lancer le reconditionnement universel
    console.log('\nüîÑ D√©marrage du reconditionnement universel...');
    const result = await preprocessor.preprocessEffect(originalCode, filename);

    // Afficher les r√©sultats
    console.log('\nüìä === R√âSULTATS DU RECONDITIONNEMENT ===');
    console.log('‚úÖ Valide:', result.isValid);
    console.log('üìù Changements:', result.changes.length);
    console.log('‚ö†Ô∏è Avertissements:', result.warnings.length);

    if (result.changes.length > 0) {
      console.log('\nüîß Liste des changements:');
      result.changes.forEach((change, index) => {
        console.log(`   ${index + 1}. ${change}`);
      });
    }

    if (result.warnings.length > 0) {
      console.log('\n‚ö†Ô∏è Avertissements:');
      result.warnings.forEach((warning, index) => {
        console.log(`   ${index + 1}. ${warning}`);
      });
    }

    // Sauvegarder le code reconditionn√©
    if (result.isValid && result.cleanCode) {
      const outputPath = path.join(__dirname, 'output-reconditioned-effect.js');
      fs.writeFileSync(outputPath, result.cleanCode);
      console.log('\nüíæ Code reconditionn√© sauvegard√©:', outputPath);

      // Afficher un aper√ßu du code transform√©
      const preview = result.cleanCode.substring(0, 800);
      console.log('\nüëÄ Aper√ßu du code reconditionn√©:');
      console.log('‚îÄ'.repeat(50));
      console.log(preview + (result.cleanCode.length > 800 ? '\n...' : ''));
      console.log('‚îÄ'.repeat(50));
    }

    // Afficher les m√©tadonn√©es extraites
    if (result.metadata) {
      console.log('\nüìã M√©tadonn√©es extraites:');
      console.log('   Nom:', result.metadata.effectName);
      console.log('   ID:', result.metadata.effectId);
      console.log('   Cat√©gorie:', result.metadata.category);
      console.log('   Version:', result.metadata.version);
    }

    // README g√©n√©r√© automatiquement
    if (result.autoGeneratedReadme) {
      const readmePath = path.join(__dirname, 'generated-README.md');
      fs.writeFileSync(readmePath, result.autoGeneratedReadme);
      console.log('\nüìñ README auto-g√©n√©r√© sauvegard√©:', readmePath);
    }

    console.log('\n‚úÖ === TEST TERMIN√â AVEC SUCC√àS ===');
    
  } catch (error) {
    console.error('‚ùå Erreur lors du reconditionnement:', error.message);
    throw error;
  }
}

// Lancer le test
testUniversalReconditioning().catch(console.error);
