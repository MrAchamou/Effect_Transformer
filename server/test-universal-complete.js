
const { UniversalPreprocessor } = require('./services/universal-preprocessor.ts');

async function testUniversalPreprocessorComplete() {
  console.log('🧪 TEST COMPLET DU MODULE UNIVERSEL\n');
  console.log('=' + '='.repeat(50));
  
  const processor = new UniversalPreprocessor();
  
  // Tests avec différents types de code
  const testCases = [
    {
      name: 'Effet de particules basique',
      code: `
class ParticleEffect {
  constructor() {
    this.particles = [];
  }
  
  animate() {
    this.particles.forEach(p => p.update());
  }
}
`,
      filename: 'particle-effect.js'
    },
    {
      name: 'Code avec métadonnées',
      code: `
export const smokeEffect = {
  id: "smoke-001",
  name: "Smoke Simulation",
  description: \`## EFFET : Fumée Réaliste
**CATÉGORIE :** Simulation
**EFFET DEMANDÉ :** Smoke_Simulation\`,
  
  initialize: function() {
    console.log('Smoke effect initialized');
  }
};
`,
      filename: 'smoke-effect.js'
    },
    {
      name: 'Code malformé nécessitant réparation',
      code: `
function brokenEffect(
  this.canvas = canvas
  this.animate = function() {
    // Code incomplet
`,
      filename: 'broken-effect.js'
    }
  ];

  let totalTests = 0;
  let passedTests = 0;
  let failedTests = 0;

  for (const testCase of testCases) {
    totalTests++;
    console.log(`\n🔬 Test ${totalTests}: ${testCase.name}`);
    console.log('-'.repeat(40));
    
    try {
      const result = await processor.preprocessEffect(testCase.code, testCase.filename);
      
      console.log(`✅ Preprocessing: ${result.isValid ? 'RÉUSSI' : 'ÉCHOUÉ'}`);
      console.log(`📊 Changements: ${result.changes.length}`);
      console.log(`📝 Métadonnées: ${result.metadata ? 'Extraites' : 'Aucune'}`);
      console.log(`📖 README auto: ${result.autoGeneratedReadme ? 'Généré' : 'Non généré'}`);
      
      if (result.changes.length > 0) {
        console.log(`🔧 Modifications:`);
        result.changes.slice(0, 3).forEach((change, i) => {
          console.log(`   ${i + 1}. ${change}`);
        });
        if (result.changes.length > 3) {
          console.log(`   ... et ${result.changes.length - 3} autres`);
        }
      }
      
      if (result.isValid) {
        passedTests++;
        console.log(`🎯 Statut: SUCCÈS`);
        
        // Test des fonctionnalités spécifiques
        const codeLength = result.cleanCode.length;
        const hasExports = result.cleanCode.includes('module.exports') || result.cleanCode.includes('window.');
        const hasStructure = result.cleanCode.includes('class ') || result.cleanCode.includes('function ');
        
        console.log(`📏 Taille du code: ${codeLength} caractères`);
        console.log(`📦 Exports: ${hasExports ? 'Présents' : 'Manquants'}`);
        console.log(`🏗️  Structure: ${hasStructure ? 'Détectée' : 'Basique'}`);
        
      } else {
        failedTests++;
        console.log(`❌ Statut: ÉCHEC - ${result.error}`);
      }
      
    } catch (error) {
      failedTests++;
      console.log(`💥 Erreur critique: ${error.message}`);
    }
  }

  // Tests de fonctionnalités spécifiques
  console.log('\n\n🎯 TESTS DE FONCTIONNALITÉS SPÉCIFIQUES');
  console.log('=' + '='.repeat(50));

  // Test génération README
  console.log('\n📖 Test génération README automatique:');
  try {
    const simpleCode = 'class TestEffect { animate() { console.log("test"); } }';
    const readme = processor.generateEffectReadme(simpleCode, 'TestEffect');
    
    if (readme && readme.includes('TestEffect') && readme.includes('VariationEngine 2.0')) {
      console.log('✅ Génération README: RÉUSSIE');
      console.log(`📝 Taille README: ${readme.length} caractères`);
    } else {
      console.log('❌ Génération README: ÉCHOUÉE');
    }
  } catch (error) {
    console.log(`❌ Erreur génération README: ${error.message}`);
  }

  // Test métadonnées
  console.log('\n🏷️  Test extraction métadonnées:');
  try {
    const metadata = processor.getExtractedMetadata();
    console.log(`✅ Métadonnées: ${metadata ? 'Disponibles' : 'Vides'}`);
  } catch (error) {
    console.log(`❌ Erreur métadonnées: ${error.message}`);
  }

  // Rapport final
  console.log('\n\n📊 RAPPORT FINAL');
  console.log('=' + '='.repeat(50));
  console.log(`🧪 Tests totaux: ${totalTests}`);
  console.log(`✅ Tests réussis: ${passedTests}`);
  console.log(`❌ Tests échoués: ${failedTests}`);
  console.log(`📈 Taux de réussite: ${((passedTests / totalTests) * 100).toFixed(1)}%`);
  
  const status = passedTests === totalTests ? 'PARFAIT' : 
                 passedTests > totalTests / 2 ? 'BON' : 'CRITIQUE';
  
  console.log(`🎯 État du module: ${status}`);
  
  if (status === 'PARFAIT') {
    console.log('\n🎉 Le module universel fonctionne parfaitement !');
    console.log('✨ Toutes les fonctionnalités sont opérationnelles');
  } else if (status === 'BON') {
    console.log('\n⚠️ Le module fonctionne mais nécessite des améliorations');
  } else {
    console.log('\n🚨 Le module nécessite des corrections majeures');
  }

  return {
    totalTests,
    passedTests,
    failedTests,
    status
  };
}

// Exécuter le test complet
if (require.main === module) {
  testUniversalPreprocessorComplete()
    .then(result => {
      console.log('\n🏁 Test terminé');
      process.exit(result.status === 'PARFAIT' ? 0 : 1);
    })
    .catch(error => {
      console.error('\n💥 Erreur fatale:', error);
      process.exit(1);
    });
}

module.exports = { testUniversalPreprocessorComplete };
