
const { UniversalPreprocessor } = require('./services/universal-preprocessor.ts');

async function testUniversalPreprocessorComplete() {
  console.log('ðŸ§ª TEST COMPLET DU MODULE UNIVERSEL\n');
  console.log('=' + '='.repeat(50));
  
  const processor = new UniversalPreprocessor();
  
  // Tests avec diffÃ©rents types de code
  const testCases = [
    {
      name: 'Effet de particules basique',
      code: `
class ParticleEffect {
  constructor() {
    this.particles = [];
  }
  
  animate() {
    this.particles.forEach(p => p.update());
  }
}
`,
      filename: 'particle-effect.js'
    },
    {
      name: 'Code avec mÃ©tadonnÃ©es',
      code: `
export const smokeEffect = {
  id: "smoke-001",
  name: "Smoke Simulation",
  description: \`## EFFET : FumÃ©e RÃ©aliste
**CATÃ‰GORIE :** Simulation
**EFFET DEMANDÃ‰ :** Smoke_Simulation\`,
  
  initialize: function() {
    console.log('Smoke effect initialized');
  }
};
`,
      filename: 'smoke-effect.js'
    },
    {
      name: 'Code malformÃ© nÃ©cessitant rÃ©paration',
      code: `
function brokenEffect(
  this.canvas = canvas
  this.animate = function() {
    // Code incomplet
`,
      filename: 'broken-effect.js'
    }
  ];

  let totalTests = 0;
  let passedTests = 0;
  let failedTests = 0;

  for (const testCase of testCases) {
    totalTests++;
    console.log(`\nðŸ”¬ Test ${totalTests}: ${testCase.name}`);
    console.log('-'.repeat(40));
    
    try {
      const result = await processor.preprocessEffect(testCase.code, testCase.filename);
      
      console.log(`âœ… Preprocessing: ${result.isValid ? 'RÃ‰USSI' : 'Ã‰CHOUÃ‰'}`);
      console.log(`ðŸ“Š Changements: ${result.changes.length}`);
      console.log(`ðŸ“ MÃ©tadonnÃ©es: ${result.metadata ? 'Extraites' : 'Aucune'}`);
      console.log(`ðŸ“– README auto: ${result.autoGeneratedReadme ? 'GÃ©nÃ©rÃ©' : 'Non gÃ©nÃ©rÃ©'}`);
      
      if (result.changes.length > 0) {
        console.log(`ðŸ”§ Modifications:`);
        result.changes.slice(0, 3).forEach((change, i) => {
          console.log(`   ${i + 1}. ${change}`);
        });
        if (result.changes.length > 3) {
          console.log(`   ... et ${result.changes.length - 3} autres`);
        }
      }
      
      if (result.isValid) {
        passedTests++;
        console.log(`ðŸŽ¯ Statut: SUCCÃˆS`);
        
        // Test des fonctionnalitÃ©s spÃ©cifiques
        const codeLength = result.cleanCode.length;
        const hasExports = result.cleanCode.includes('module.exports') || result.cleanCode.includes('window.');
        const hasStructure = result.cleanCode.includes('class ') || result.cleanCode.includes('function ');
        
        console.log(`ðŸ“ Taille du code: ${codeLength} caractÃ¨res`);
        console.log(`ðŸ“¦ Exports: ${hasExports ? 'PrÃ©sents' : 'Manquants'}`);
        console.log(`ðŸ—ï¸  Structure: ${hasStructure ? 'DÃ©tectÃ©e' : 'Basique'}`);
        
      } else {
        failedTests++;
        console.log(`âŒ Statut: Ã‰CHEC - ${result.error}`);
      }
      
    } catch (error) {
      failedTests++;
      console.log(`ðŸ’¥ Erreur critique: ${error.message}`);
    }
  }

  // Tests de fonctionnalitÃ©s spÃ©cifiques
  console.log('\n\nðŸŽ¯ TESTS DE FONCTIONNALITÃ‰S SPÃ‰CIFIQUES');
  console.log('=' + '='.repeat(50));

  // Test gÃ©nÃ©ration README
  console.log('\nðŸ“– Test gÃ©nÃ©ration README automatique:');
  try {
    const simpleCode = 'class TestEffect { animate() { console.log("test"); } }';
    const readme = processor.generateEffectReadme(simpleCode, 'TestEffect');
    
    if (readme && readme.includes('TestEffect') && readme.includes('VariationEngine 2.0')) {
      console.log('âœ… GÃ©nÃ©ration README: RÃ‰USSIE');
      console.log(`ðŸ“ Taille README: ${readme.length} caractÃ¨res`);
    } else {
      console.log('âŒ GÃ©nÃ©ration README: Ã‰CHOUÃ‰E');
    }
  } catch (error) {
    console.log(`âŒ Erreur gÃ©nÃ©ration README: ${error.message}`);
  }

  // Test mÃ©tadonnÃ©es
  console.log('\nðŸ·ï¸  Test extraction mÃ©tadonnÃ©es:');
  try {
    const metadata = processor.getExtractedMetadata();
    console.log(`âœ… MÃ©tadonnÃ©es: ${metadata ? 'Disponibles' : 'Vides'}`);
  } catch (error) {
    console.log(`âŒ Erreur mÃ©tadonnÃ©es: ${error.message}`);
  }

  // Rapport final
  console.log('\n\nðŸ“Š RAPPORT FINAL');
  console.log('=' + '='.repeat(50));
  console.log(`ðŸ§ª Tests totaux: ${totalTests}`);
  console.log(`âœ… Tests rÃ©ussis: ${passedTests}`);
  console.log(`âŒ Tests Ã©chouÃ©s: ${failedTests}`);
  console.log(`ðŸ“ˆ Taux de rÃ©ussite: ${((passedTests / totalTests) * 100).toFixed(1)}%`);
  
  const status = passedTests === totalTests ? 'PARFAIT' : 
                 passedTests > totalTests / 2 ? 'BON' : 'CRITIQUE';
  
  console.log(`ðŸŽ¯ Ã‰tat du module: ${status}`);
  
  if (status === 'PARFAIT') {
    console.log('\nðŸŽ‰ Le module universel fonctionne parfaitement !');
    console.log('âœ¨ Toutes les fonctionnalitÃ©s sont opÃ©rationnelles');
  } else if (status === 'BON') {
    console.log('\nâš ï¸ Le module fonctionne mais nÃ©cessite des amÃ©liorations');
  } else {
    console.log('\nðŸš¨ Le module nÃ©cessite des corrections majeures');
  }

  return {
    totalTests,
    passedTests,
    failedTests,
    status
  };
}

// ExÃ©cuter le test complet
if (require.main === module) {
  testUniversalPreprocessorComplete()
    .then(result => {
      console.log('\nðŸ Test terminÃ©');
      process.exit(result.status === 'PARFAIT' ? 0 : 1);
    })
    .catch(error => {
      console.error('\nðŸ’¥ Erreur fatale:', error);
      process.exit(1);
    });
}

module.exports = { testUniversalPreprocessorComplete };
